# VM作ろうと思ったらどっちかというとCPUエミュレータだった

この記事は[進捗 Advent Calendar 2020](https://github.com/t-sin/shinchoku-advent-calendar-2020)の9日目の記事です。

## 背景

仮想機械とそのツールチェインをつくろうとした時期がありました。2018年の6月から8月くらいまでの時期です。それまで小さな言語というか小さなLispのインタプリタしか書いたことがなかったため(それはいまでも変わりませんが)、仮想機械というものに強い憧れを抱いておりました(それもいまでも変わりません)。計算機がわからなかったし仮想機械を構成してその上に言語を載せることで、多少なりとも計算機への理解が生まれるのではないかと考えたわけです。ちなみにいまでも計算機はちっともわからないです。

そんなわけでつくっていたのがこちらのリポジトリです。

https://github.com/t-sin/svm

## どんなものだったか

つくろうとしたVMは以下のようなものでした:

- レジスタマシン
    - レジスタは8本
    - うちプログラムカウンタが1つ
- メモリとしてバイト配列がひとつ
- プログラムもデータも同じメモリの中に置かれる
- 命令のバイナリ表現はオペランド含めて24bit固定
- VM用のアセンブリ言語を用意しようとした

スタックマシンではなくレジスタマシンを選んだのは、できるだけ低レベルなことをしたかったからのようです。メモリがバイト配列なのもそれが理由ですね。実装にはCommon Lispを用いたのでメモリの型は`(simple-array (unsigned-byte 8) xxx)`です。プログラムとデータが同じメモリに置かれるのは、自己書き換えコードとかやりたかったりしたのかもしれない。

そういえばVMの構造体にメモリのdumperとかaccessor用の関数のためのスロットがあるので、おそらくVMの実行状態をファイルに書き出すことを目標に入れていたようです。記憶が定かではないのですが、Common Lispのイメージ指向 (`save-lisp-and-die`) なことをしたかったのでしょうかね。

プログラムとデータが同じメモリに置かれるということで、命令のフォーマットの設計に苦労してたのは覚えています。命令のbit長はオペコードやオペランドを含めて24bit固定でした。命令のオペランド数によって24bitの中の構造が違うっぽいのですが、オペランド数によって構造が異なるという感じだったようです。[ここに設計書いてあった](https://twitter.com/sin_clav/status/1018505065114492928)、えらい。命令は固定長なのにオペランドにはレジスタだけでなくメモリも指定可能とは…。書いているいま見ると、メモリ-レジスタ間のデータ移動命令とレジスタしか触らない演算系の命令を分けておけば、こういうむずかしげな命令フォーマットにならなかったんですけどね。アセンブラやったことがなかったからわからなかったのでしょう。もちろんアラインメントという概念も脳になかったので、なんとなくすべてのデータが1バイト区切りで置かれます。

VM用のアセンブリ言語は、CPUっぽいものだったらテキストファイルに書いたプログラムをコンパイルっぽいことしたいと考えてたのだと思います。テキストで書いたプログラムをアセンブルしてVMにロードし実行すると、ツールチェインをつくった感があってたのしいとかそういう理由で。そういえばこのリポジトリ、x86はともかくARMなんかの実機のアセンブリ言語が未知すぎて怖かったので、仮想機械の簡単な命令で低レベルプログラミングの練習をしたかったという意図もあったような気がします。

そんなかんじです。

SVMは仮想機械 (プログラミング言語処理系のための) といいつつ、SECDマシンのような抽象化はなくかなり低レベルなつくりです。というかCPU…では…？ 当時よりは理解の進んだいまのぼくが要約するなら「オレオレアーキテクチャをソフトウェアで再現して、その上にプログラミング環境を構築したいぜ」とも言うべきリポジトリになっています。仮想機械というよりはCPUエミュレータ。

ちなみに動作確認のために書いたSVM用のアセンブリ言語のコードがこれですが、

```
;; this is a sample code for svm-as

.data
    testnum 42
    teststr "fourty two"

.code
    load %testnum $r0  ; load from memory
    load 43 $r1        ; load from immediate
    add $r0 $r1 $r2    ; add 42 + 43
    store $r2 &100     ; store into addr (100)

    load 20 $r4
    load 21 $r5
    ifeq :END $r4 $r5  ; junp to :END if 20 ($4) is equal to 21 ($r5)
    hw                 ; hello assembly world!
:END
    exit               ; exit program
```

なんというかほんとうにただのアセンブリ言語ですありがとうございました。

このころはリンカ・ローダのことも聞いたことあったかなかったかくらいでしたが、奇しくもアセンブラによってアセンブリプログラムのデータ表現を実際にメモリに正しく配置する関数に`load`とか書かれていて、くそ雑魚ローダっぽいものをつくっていたんだなという感慨が湧きます。

twitterをほじくり返すと[最初にアセンブラからローダまでが動いてメモリにプログラムが配置されたところ](https://twitter.com/sin_clav/status/1014877206949056517)とか、[分岐命令のためのラベルがとりあえず動いた瞬間](https://twitter.com/sin_clav/status/1018505065114492928)とかがでてきてなんだかとっても楽しそう。というか楽しかったことが思い出されました。

## なぜやめてしまったのか

アセンブリ言語のラベルをうまく計算してメモリにロードできなかったからです。たしか「メモリ上のラベルの位置がわかるためにはメモリ上のデータの配置を確定させる必要があるが、データの配置 (と内容) を確定させるためにはメモリ上のラベルの位置がわからなくてはならない」という問題にぶちあたって転んでしまったからです。今思えば次のようにすれば解決できたなと思うくらいには成長した気がします。すなわち、ラベル情報を埋め込む場所を覚えておいてダミー値を入れ、その状態で命令を一旦メモリに置いてしまい、その配置からラベル位置を知ってダミー値のところに書き込めばよいと。

SVMの前には低レベル的なことはJVMのクラスファイルをパースして遊んだくらいなので (これは後の日に書きます)、まあ知らないにしてはがんばっているなあという感想です。

## SVMを思いついたときにやろうとしたこと

そういえばSVMはString VMの略でした。最初に思い付いたとき「VMのメモリが文字列であればいいな」「ダンプも楽だし」というアイデアだったので、やってみようとその名前にしました。が、そもそも仮想機械やCPUのアーキテクチャ自体をよくわかっていない状態だったので、いったん取り止めた記憶があります。じつはこっそり最近[ちょこっとだけそのことについて考えたりもしてたんですが](https://github.com/t-sin/svm/blob/string-vm/doc/texual-memory.md)、やっぱ無理そうなのでやめました。

## おわりに

振り返ると、低レベルを志向しておきながら数値演算はCommon Lispのほうでやってしまっていたり (キャリーフラグとかそういうレジスタ一切なし) 、ディレクトリ構造が若干妙だったり (サブシステムをasdfシステムにディレクトリごと切ってあるのにルートにぽつんとVMの定義があったりするなど)、package-inferred-systemになっていたり (近ごろぼくは使うのをやめました)と反省点はかなりあります。しかし今みても続きあるいは書き直しをしたくなってくる、アツくて思い入れのあるリポジトリでしたので、エタっているにしてもここでようやく日の目を見ることになってよかったです。

きっとまた同じようなことをやりたくなることがあると思います。そのときは、命令セットや命令表現を工夫したり、先に述べたアセンブラの問題をうまく解決したり、デバッグのための機能を充実させたり、入出力やFFI等の機能を足すなどして、もうちょっと高度で実用っぽい雰囲気のある環境としてみたいです。そしてなにより、その上で動く高級な言語処理系をつくっておいて、レトロコンピューティング環境というかファンシーコンソールみたいなことをしてみたいです。

先は長い。
